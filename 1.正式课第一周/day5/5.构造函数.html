<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    // Fn就是一个函数；
    function Fn(name,age) {
        // 先默认创建一个空对象；
        // 把函数体中this指向这个空对象；this和这个空对象的地址是一样的；
        this.name=name;// 给空对象新增键值对；
        this.age=age;
        // 把这个this默认return返回
        //return [];
    }
    // new ： 关键字；
    // 1.new + 函数；函数执行前先默认创建一个空对象；
    // 2.让当前函数中的this指向了这个空对象
    // 3.代码执行完之后，会默认把this return出去
    //Fn();
    var f  = new Fn;//{name:undefined,age:undefined}
    var f1  = new Fn;
    //Fn();// 还是一个普通的函数；
    console.log(f);// {name: "马老师", age: 20}
    // f 就是Fn的一个实例；
    // Fn就是一个构造函数；也是一个自定义类；
    // 构造函数中的this指向当前的实例；
    // 实例=new 类；

    // 区别
    // 1. 函数执行： 形成私有作用域--> 形参赋值---> 变量提升-->代码从上到下运行--> 作用域是否销毁
    //   构造函数执行： 形成私有作用域--> 形参赋值---> 变量提升-->默认创建空对象-->this 指向空对象-->代码从上到下运行--> 默认返回把this返回--> 作用域是否销毁

    // 2.构造函数如果不需要传参数，可以省略执行的小括号；
    // 3.构造函数中如果return一个基本数据类型值，不能修改默认返回的实例；如果返回一个引用的值，将会修改默认返回的实例；
    // 4. instanceOf : 检测当前实例是否属于某个类的；是返回true，不是返回false；

    console.log(f instanceof Fn);
    console.log(f instanceof Number);
    console.log([] instanceof Array);
    console.log({} instanceof Array);
    var a = new Object()
    console.log(a );// true
    function f() {
    }
    console.log(f instanceof Function);
    function Fr() {
    }
    var g = new Fr;
    Fr();
    // 构造函数、类 、实例
</script>
</body>
</html>