<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    // 1. typeof
    // 2. instanceOf
    // 3. constructor
    // 4. Object.prototype.toString.call()
    // 1. typeof
    //   1) typeof 返回一个字符串；字符串中内容，代表当前的数据类型
    //   2) typeof null --> "object" null代表空对象指针
    //   3) typeof +对象数据类型--> "object";不能具体细分对象数据类型中的对象、数组、正则；
    //  typeof 可以检测函数；
   /* console.log(typeof 1);
    console.log(typeof "");
    console.log(typeof null);// "object"
    console.log(typeof undefined);// "undefined"
    console.log(typeof {});// "object";
    console.log(typeof []);//"object"
    console.log(typeof /\d/);//"object"
    console.log(typeof Date);// "function"
    console.log(typeof Object);*/// "function"

    // 2. instanceOf : 检测实例是否属于某个类；如果是返回true；不是返回false；
    // 1. 只要当前类在当前实例的原型链上，都返回true；
    // 2. instanceOf 不能检测通过字面量方式创建的基本数据类型的值；
    // 3. 继承可以导致检测结果不准确；

   /*function Fn() {

    }
    var f = new Fn;// f 是由Fn构建出来的；f是Fn 的一个实例；
    console.log(f instanceof Fn);
    console.log(f instanceof Function);// false
    console.log(f instanceof Object);// true

    // Fn.prototype 是Object的一个实例 ={}
    var obj = {};
    console.log(obj instanceof Array);// false
    console.log([] instanceof Object);*/// true
   /* var a = 100;// 不是一个标准的实例；
    console.log(a instanceof Number);// false
    var b = new Number(1);
    var obj = {};
    console.log(obj instanceof Object);
    function fn() {}
    console.log(fn instanceof Function);*/

   /*function A() {

   }
   function B() {

   }
   var b = new B;
   B.prototype = new A;
   console.log(b instanceof A);*/// false


    // 3.constructor :
    // f.constructor : 校验当前实例是否是Fn的一个实例；是的话返回true；不是返回false；
    // 1. 当修改原型的空间地址；或者通过继承修改了原型链；都会导致检测结果不准确；
    /*function Fn() {
    }
    var f = new Fn;
    console.log(f.constructor === Object);// false;
    var num = 1;
    console.log(num.constructor === Number);*/// true
    //console.log(Null);// Null这个类是存在的，只是浏览器不让调用；

    /*function sum() {
        arguments.__proto__=Array.prototype;
        console.log(arguments.constructor === Object);// false
    }
*/

    // 4. Object.prototype.toString.call()
    // 通过自定义类创建的实例，返回"[object Object]";
    /*var obj = {};
     obj.toString()// "[object Object]"
     Object.prototype.toString.call(obj)// "[object Object]"
     var ary = [];
     ary.toString();// "";ary是调用了Array原型中的toString;
     console.log(Object.prototype.toString.call(ary));// "[object Array]";
     var num =1;
     var num1 = new Number(1);
     console.log(Object.prototype.toString.call(num1));//"[object Number]"
     console.log(Object.prototype.toString.call(null));//"[object Null]"*/
   /* function A() {

    }
    function B() {

    }
    B.prototype= new A;
    var b = new B;
    // 全局window下，并没有toString这个方法；那么会通过__proto__一直向上查找到Object；最终可以使用Object原型中的toString;让toString 执行，并且改变了toString中的this指向；返回一个"[object 内置类]"
    console.log(toString.call(b));*/// {}
    /*if(toString.call(ary)==="[object Array]"){

    }*/
    (function () {
        var obj = {

        }
    })()

</script>
</body>
</html>