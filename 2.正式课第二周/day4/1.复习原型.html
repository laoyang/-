<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    // 面向对象：构造函数  原型模式
    // this : 作用域下的this；
    function Fn(){
        /*var  obj = {};
        this-->obj;*/
        var num = 1;
        this.a = num;
        // return this;
    }
    // Fn 自定义类； 类一定是一个函数；但函数不一定是类；
    // 内置类： Number String Boolean  Null Undefined  Symbol
    // Object Array  RegExp  Date  Function ...
  /*   var f = new Fn;// f 就是构造函数构建出来的实例；是构造函数的返回值；
    var f1 = new Fn;
    Fn.prototype.getX=function () {

    }
    f.getX()*/

    //实例继承了类的公有属性；
    // 1.每一个函数数据类型天生自带一个prototype属性，这个属性的属性值是一个对象数据类型；
    // 2. prototype的属性值天生自带constructor属性，其属性值指向当前原型所属类
    // 3. 每一个对象数据类型天生自带一个__proto__属性，其属性值指向当前实例所属类的原型；

    // 原型的扩展
    // 内置类
    var ary = [];
    Array.prototype.myPush =function () {

    }
   // 如果名字相同，就会把原有的进行覆盖
    Array.prototype.pop =function () {

    }
    // 内置类原型的空间不能被改变；
    Array.prototype ={}

    // 自定义类
    Fn.prototype.getX=function () {

    }
    // 导致constructor丢失；
    Fn.prototype = {}


   /* var num = 1;
    num.hasOwnProperty()
    var  ary  =[]
    num.hasOwnProperty===ary.hasOwnProperty*/

    /*ary.pop()
    ary1.pop()*/

    //__pro__
    /*var num = 1;
    console.log(num.__proto__);
    num.toFixed(2)*/
    //
    // Fn:{arguments:"",caller:"",name:"",prototype:{}}
    // 只有函数具有prototype和__proto__;其他的都只有__proto__;
    // 原型链：
    //var ary=[12];
    //isPrototypeOf : 原型.isPrototypeOf(实例)；如果是返回true；不是返回false;
    //console.log(Object.prototype.isPrototypeOf(ary));




</script>
</body>
</html>