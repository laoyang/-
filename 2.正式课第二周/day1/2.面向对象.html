<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    // 单例模式  工厂模式    构造函数模式  原型模式

    // var obj = [{name:"黄磊",age:20}]
    // 前后端交互：javascript 运行在浏览器；Java运行在服务器上；

    // 工厂模式： 实现了代码的封装；减少了代码的冗余；
    /*function fn() {

    }*/
    // 构造函数模式
   /* function Fn() {
        // var obj = {};
        // 改变了当前函数中的this指向，指向了这个空对象
        this.name=100;
        this.age=200;
        //var  y  =10;
        // 把对象this默认返回；
         //return 1;
    }
    // new ： 放在函数的前面，函数就变成一个构造函数
    var f = new Fn();*/// Fn 是一个构造函数，也是一个类；自定义类；
    // 1.构造函数中的this指向当前的实例；构造函数的返回值就叫实例；
    // 2. instanceOf : 检测当前实例是否属于某个类；
    // 3. return 出一个基本数据类型，不会影响默认返回的this；如果返回一个引用数据类型，则会覆盖默认返回的this；
    // console.log(f);// {name:100,age:200} name和age都是f的私有属性；

    // 原型模式

    // 1.每一个函数数据类型（函数、类）天生自带一个prototype属性，其属性值是一个对象数据类型
    // 2.prototype的属性值中天生自带一个constructor属性，其属性值指向当前当前原型所属的类；
    // 3.每一个对象数据类型都天生自带一个__proto__属性，其属性值指向当前实例所属的类的原型；
    function Fn() {
        this.x =100;
        this.y = 200;
    }
    Fn.prototype.getX  =function () {
        console.log(this.x);
    };
    var f1 = new Fn;//{x:100,y:200}
    var f2 = new Fn;//{x:100,y:200}
    console.log(f1.getX === f2.getX);//false;

    console.log(f1.__proto__ === Fn.prototype);// true
    f2.getX();
    f1.getX();
    console.log(f1.hasOwnProperty);

    // f1.getX: 先找自己属性名是getX的属性值，如果没有这个属性，会默认通过__proto__继续向上查找，如果所属类的原型中也不存在，会继续通过原型中__proto__继续向上查找，直到找到Object的原型为止；如果也没有就输出undefined；

    // f1原型链上的属性都是公有属性；
    // hasOwnProperty:判断当前属性是否是私有属性；如果是私有属性，则返回true，不是返回false；
    console.log(f1.hasOwnProperty("x"));// true
    console.log(f1.hasOwnProperty("getX"));// false

    // in : 验证当前属性是否属于这个对象;不能区分是否是私有属性；不管私有或公有都返回true
    console.log("x" in f1);
    console.log("getX" in f1);

    // hasPublicProperty: 如果是公有返回true，不是返回false；
    function hasPublicProperty(obj,attr) {
        /*if(attr in obj) {
            // 是他的一个属性
            if (!obj.hasOwnProperty(attr)) {
                // 验证不是私有属性；
                return true;
            }
        }
        return false;*/
        return attr in obj && !obj.hasOwnProperty(attr) ?true :false;
    }
   /* hasPublicProperty(f,"getX")
    hasPublicProperty(f,"x")*/

    var  obj = {a:1}
    console.log(obj instanceof Object);
    console.log(new Object());
    console.log(Object.prototype.__proto__);// null
</script>
</body>
</html>